/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.19.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, Binary, FundMsg, AddressType, Addr, Cw20ReceiveMsg, Link, QueryMsg, Status, GetCampaignResponse, Campaign, GetDonorResponse, Donor } from "./Funding.types";
export interface FundingReadOnlyInterface {
  contractAddress: string;
  queryTotalDonated: () => Promise<Uint128>;
  queryGetCampaign: ({
    campaignName
  }: {
    campaignName: string;
  }) => Promise<GetCampaignResponse>;
  queryGetDonor: ({
    donorAddress
  }: {
    donorAddress: string;
  }) => Promise<GetDonorResponse>;
}
export class FundingQueryClient implements FundingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.queryTotalDonated = this.queryTotalDonated.bind(this);
    this.queryGetCampaign = this.queryGetCampaign.bind(this);
    this.queryGetDonor = this.queryGetDonor.bind(this);
  }

  queryTotalDonated = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_total_donated: {}
    });
  };
  queryGetCampaign = async ({
    campaignName
  }: {
    campaignName: string;
  }): Promise<GetCampaignResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_get_campaign: {
        campaign_name: campaignName
      }
    });
  };
  queryGetDonor = async ({
    donorAddress
  }: {
    donorAddress: string;
  }): Promise<GetDonorResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_get_donor: {
        donor_address: donorAddress
      }
    });
  };
}
export interface FundingInterface extends FundingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  addCampaign: ({
    campaignAddress,
    campaignName
  }: {
    campaignAddress: string;
    campaignName: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  disableCampaign: ({
    campaignName
  }: {
    campaignName: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  fund: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  adminFund: ({
    amount,
    fundMsg,
    to
  }: {
    amount: Uint128;
    fundMsg: FundMsg;
    to: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateAdmins: ({
    admins
  }: {
    admins: Addr[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    blacklistContractAddress,
    cw20DonationTokenAddress,
    generalFundAddress,
    nativeTokenDenom,
    sparkTokenContractAddress
  }: {
    blacklistContractAddress?: string;
    cw20DonationTokenAddress?: string;
    generalFundAddress?: string;
    nativeTokenDenom?: string;
    sparkTokenContractAddress?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateNickname: ({
    nickname
  }: {
    nickname?: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateValidatorLink: ({
    validatorLink
  }: {
    validatorLink?: Link;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class FundingClient extends FundingQueryClient implements FundingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.addCampaign = this.addCampaign.bind(this);
    this.disableCampaign = this.disableCampaign.bind(this);
    this.receive = this.receive.bind(this);
    this.fund = this.fund.bind(this);
    this.adminFund = this.adminFund.bind(this);
    this.updateAdmins = this.updateAdmins.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.updateNickname = this.updateNickname.bind(this);
    this.updateValidatorLink = this.updateValidatorLink.bind(this);
  }

  addCampaign = async ({
    campaignAddress,
    campaignName
  }: {
    campaignAddress: string;
    campaignName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_campaign: {
        campaign_address: campaignAddress,
        campaign_name: campaignName
      }
    }, fee, memo, funds);
  };
  disableCampaign = async ({
    campaignName
  }: {
    campaignName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      disable_campaign: {
        campaign_name: campaignName
      }
    }, fee, memo, funds);
  };
  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee, memo, funds);
  };
  fund = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      fund: {}
    }, fee, memo, funds);
  };
  adminFund = async ({
    amount,
    fundMsg,
    to
  }: {
    amount: Uint128;
    fundMsg: FundMsg;
    to: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_fund: {
        amount,
        fund_msg: fundMsg,
        to
      }
    }, fee, memo, funds);
  };
  updateAdmins = async ({
    admins
  }: {
    admins: Addr[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_admins: {
        admins
      }
    }, fee, memo, funds);
  };
  updateConfig = async ({
    blacklistContractAddress,
    cw20DonationTokenAddress,
    generalFundAddress,
    nativeTokenDenom,
    sparkTokenContractAddress
  }: {
    blacklistContractAddress?: string;
    cw20DonationTokenAddress?: string;
    generalFundAddress?: string;
    nativeTokenDenom?: string;
    sparkTokenContractAddress?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        blacklist_contract_address: blacklistContractAddress,
        cw20_donation_token_address: cw20DonationTokenAddress,
        general_fund_address: generalFundAddress,
        native_token_denom: nativeTokenDenom,
        spark_token_contract_address: sparkTokenContractAddress
      }
    }, fee, memo, funds);
  };
  updateNickname = async ({
    nickname
  }: {
    nickname?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_nickname: {
        nickname
      }
    }, fee, memo, funds);
  };
  updateValidatorLink = async ({
    validatorLink
  }: {
    validatorLink?: Link;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_validator_link: {
        validator_link: validatorLink
      }
    }, fee, memo, funds);
  };
}